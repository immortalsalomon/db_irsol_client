# Internal dependencies
from db_irsol.settings import Settings

# libraries dependencies
import requests
import json
import jwt
import time


class AuthenticateGateway:
    """ This class is used to manage the authentication of a user on the server.
        It manages a user's credentials and the generated jwts. The latter allow
        faster and more secure authentication.

    :param ENTRY_POINT: The name of the .php file, on the server, that handles user authentication.
    :type ENTRY_POINT: str
    :param auth_data: Contains the credentials (username, password) passed by the user for authentication on the server.
    :type auth_data: str
    :param token: JWT token to authenticate on the server.
    :type token: str
    :param token_expiration_time: The Unix Timestamp of when the token will expire.
    :type token_expiration_time: int
    """

    ENTRY_POINT = 'Authenticate.php'

    def __init__(self, auth_username, auth_password):
        """ Constructor method
        """
        self.__auth_data = {'auth_username': auth_username,
                            'auth_password': auth_password}

        self.__token = self.generate_token()
        if self.__token is not None:
            self.__token_expiration_time = jwt.decode(self.__token, options={"verify_signature": False})['exp'] \
                if self.__token is not None else None
        else:
            self.__token_expiration_time = None

    #######################
    ### OFFLINE METHODS ###
    #######################

    def get_token(self):
        """ Returns a token, generated by the server, with the credentials given during object creation.
            If a token is no longer valid, a new one is generated with the same credentials.
            If the credentials are not valid, no token is returned or generated.

        :return: A string containing a token to authenticate on the server.
        :rtype: str
        """
        if self.__token is not None and \
                time.time() >= self.__token_expiration_time + Settings.TOKEN_TIMESTAMP_EXPIRATION_SECURITY:
            self.__token = self.generate_token()

            if self.__token is not None:
                self.__token_expiration_time = jwt.decode(self.__token, options={"verify_signature": False})['exp']
            else:
                self.__token_expiration_time = None

        return self.__token

    def get_username(self):
        """ Returns the user name used for authentication.

        :return: A string containing the user name.
        :rtype: str
        """

        return self.__auth_data['auth_username']

    def get_password(self):
        """ Returns the password of the username used for authentication.

        :return: A string containing the password of the user.
        :rtype: str
        """

        return self.__auth_data['auth_password']

    def get_expiration_time(self):
        """ Returns the expiry Unix Timestamp of the currently used token.

        :return: The expiry Unix Timestamp of the currently used token as int.
        :rtype: int
        """

        return self.__token_expiration_time

    ######################
    ### ONLINE METHODS ###
    ######################

    def are_credentials_valid(self):
        """ Returns True if the credentials passed during object creation are valid.
            Returns False if the credentials are invalid or an error occurs.
            Errors can be viewed in the console.

        :return: True if the credentials are valid. Otherwise False.
        :rtype: bool
        """

        result = False

        payload = {'validate_credentials': ""}

        # try to perform the request
        try:
            request = requests.get(Settings.api_url + "/" + AuthenticateGateway.ENTRY_POINT, params=payload,
                                   json=self.__auth_data)

            # Convert string to list.
            parsed_result = json.loads(request.text[1:-1])

            if request.ok:
                result = True
            elif 'error' in parsed_result:
                print('Error arise: ' + str(parsed_result['error']))

        except requests.exceptions.ConnectionError:
            print("Connection to server "
                  + Settings.api_url
                  + " failed. Please check if the server is working or if you have internet connection.")
        except requests.exceptions.Timeout:
            print("Request timeout. Maybe set up for a retry, or continue in a retry loop.")
        except requests.exceptions.TooManyRedirects:
            print("Bad URL (" + Settings.api_url + "). Try a different one")
        except requests.exceptions.RequestException as e:
            print("Some error occur: \n" + str(e))
        except json.decoder.JSONDecodeError as e:
            print("There was a problem accessing the response: \n" + str(e))

        return result

    def is_token_valid(self):
        """ Returns True if the token is still valid.
            Returns False if the token is no more valid or an error occurs.
            Errors can be viewed in the console.

        :return: True if the token is valid. Otherwise False.
        :rtype: bool
        """

        result = False

        if self.get_token() is None:
            print("token is none")
            return result

        payload = {'validate_token': ""}
        body_data = {'auth_token': self.__token}

        # try to perform the request
        try:
            request = requests.get(Settings.api_url + "/" + AuthenticateGateway.ENTRY_POINT, params=payload,
                                   json=body_data)

            # Convert string to list.
            parsed_result = json.loads(request.text[1:-1])

            if request.ok:
                result = True
            elif 'error' in parsed_result:
                print('Error arise: ' + parsed_result['error'])

        except requests.exceptions.ConnectionError:
            print("Connection to server "
                  + Settings.api_url
                  + " failed. Please check if the server is working or if you have internet connection.")
        except requests.exceptions.Timeout:
            print("Request timeout. Maybe set up for a retry, or continue in a retry loop.")
        except requests.exceptions.TooManyRedirects:
            print("Bad URL (" + Settings.api_url + "). Try a different one")
        except requests.exceptions.RequestException as e:
            print("Some error occur: \n" + str(e))
        except json.decoder.JSONDecodeError as e:
            print("There was a problem accessing the response: \n" + str(e))

        return result

    def generate_token(self):
        """ Returns a token if the credentials passed during object creation are valid and no error occurs.
            Otherwise returns None. Errors can be viewed in the console.

        :return: A token to authenticate on the server.
        :rtype: str
        """

        result = None

        # Dictionary containing all the params value.
        payload = {'get_token': ""}

        # try to perform the request
        try:
            request = requests.get(Settings.api_url + "/" + AuthenticateGateway.ENTRY_POINT, params=payload,
                                   json=self.__auth_data)

            # Convert string to list.
            parsed_result = json.loads(request.text[1:-1])

            if request.ok:
                result = parsed_result['token']
            elif 'error' in parsed_result:
                print('Error arise: ' + str(parsed_result['error']))

        except requests.exceptions.ConnectionError:
            print("Connection to server "
                  + Settings.api_url
                  + " failed. Please check if the server is working or if you have internet connection.")
        except requests.exceptions.Timeout:
            print("Request timeout. Maybe set up for a retry, or continue in a retry loop.")
        except requests.exceptions.TooManyRedirects:
            print("Bad URL (" + Settings.api_url + "). Try a different one")
        except requests.exceptions.RequestException as e:
            print("Some error occur: \n" + str(e))
        except json.decoder.JSONDecodeError as e:
            print("There was a problem accessing the response: \n" + str(e))

        return result
